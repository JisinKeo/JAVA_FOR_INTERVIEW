## 1. 자바 기초
-----------------------
### JDK와 JRE의 차이점은 무엇입니까?

JDK는 Java 언어를 개발하고 컴파일하는 데 사용됩니다. 따라서 JDK는 Java 개발자에게 필요한 도구들을 포함하고 있습니다. <br/>
JRE는 Java 애플리케이션을 실행하는 데 필요한 실행 환경을 제공합니다. 따라서 JRE는 일반 사용자들이 Java 애플리케이션을 실행하는 데 필요한 요소들을 포함하고 있습니다. <br/>
JRE는 Java 애플리케이션을 실행하는 데 필요한 최소한의 구성 요소만을 포함하고 있기 때문에 개발 도구나 컴파일러는 포함되어 있지 않습니다. <br/>
JDK는 JRE를 생성하는 역할을 수행하며, JRE는 JDK에 포함된 도구들 없이는 Java 애플리케이션을 개발하거나 수정할 수 없습니다. <br/>

-----------------------
### ==와 equals의 차이점은 무엇입니까?

"==" 연산자는 두 개의 객체의 레퍼런스(주소)를 비교합니다.
즉, 두 개의 객체가 메모리에서 동일한 위치를 가리키고 있는지를 확인합니다.
"equals()" 메서드는 두 개의 객체의 내용이 동일한지 비교합니다.
기본적으로 Object 클래스에서 상속받은 "equals()" 메서드는 "==" 연산자와 동일한 결과를 반환하도록 구현되어 있으며, 이는 객체의 레퍼런스(주소)를 비교합니다.
하지만 많은 클래스들은 "equals()" 메서드를 오버라이딩하여 객체의 내용을 비교하도록 재정의합니다. 이 경우에는 두 객체의 내용이 같으면 true를 반환하고, 다르면 false를 반환합니다.

-----------------------
### 두 객체가 동일한 hashCode를 가지면 Equals()가 참이어야 합니다, 그렇죠?

hashCode()와 equals()는 서로 다른 목적을 가지고 있으며, hashCode()가 동일하다고 해서 equals()가 참이 되어야 하는 것은 아닙니다. 
해시 충돌이 발생할 수 있으므로, equals() 메서드를 사용하여 정확히 객체의 내용을 비교해야 합니다.

-----------------------
### 자바에서 final의 기능은 무엇입니까?
불변성, 안정성 등을 목적으로 다양한 요소에 적용된다. <br/>
변수: final 변수는 상수로 취급되며, 값을 한 번 할당하면 변경할 수 없습니다. 즉, 변수에 대한 변경이 금지됩니다. <br/>
메서드: final 메서드는 하위 클래스에서 오버라이딩(재정의)할 수 없는 메서드를 나타냅니다. <br/>
클래스: final 클래스는 상속될 수 없는 클래스를 나타냅니다. 

-----------------------
### 자바에서 Math.round(-1.5)는 무엇을 의미합니까?
Math.round() 메서드는 실수 값을 받아와서 그 값에 가장 가까운 정수로 반올림한 결과를 반환합니다. <br/>
따라서 Math.round(-1.5)는 -1.5를 반올림하여 가장 가까운 정수인 -1을 반환합니다. 

-----------------------
### String은 기본 데이터 타입입니까?
아니요, String은 기본 데이터 타입(primitive type)이 아니라 참조 타입(reference type)입니다. <br/>
String은 참조 타입이므로, 객체를 힙(heap)에 할당하고 그 주소를 스택에 저장합니다. <br/>
Java에서 String은 불변(immutable)입니다. 객체 수정 시 새로운 객체를 생성해야만 합니다.

-----------------------
### 자바에서 문자열을 조작하는 클래스는 무엇이 있습니까? 각 클래스의 차이점은 뭘까요?
String 클래스는 불변(immutable)입니다. 즉, 한번 생성된 String 객체는 변경할 수 없습니다. 
StringBuilder 클래스는 가변(mutable)한 객체입니다. 즉, StringBuilder 객체는 생성 후에도 변경할 수 있습니다.
StringBuffer 클래스도 StringBuilder와 마찬가지로 가변(mutable)한 객체입니다. 
StringBuffer는 StringBuilder와 달리 스레드에 안전(thread-safe)합니다. 여러 스레드 작업 시 StringBuffer가 유리합니다.

-----------------------
### String str ="i"와 String str = new String("i")가 동일합니까?
String str = "i";의 경우, 문자열 리터럴 "i"가 스트링 풀(String pool)이라는 특별한 영역에 저장됩니다. 스트링 풀은 JVM의 힙 메모리에 있는 공간입니다.
String 객체를 다시 만들 경우, JVM은 스트링 풀에 있는 같은 값을 가리키도록 합니다. 이 방법은 메모리를 효율적으로 사용하도록 돕습니다.
String str = new String("i");의 경우, 새로운 String 객체가 힙 메모리에 생성됩니다. 
이렇게 생성된 String 객체는 스트링 풀과 상관없이 항상 새로운 메모리 공간을 차지합니다.

-----------------------
### 문자열을 반전시키는 가장 좋은 방법은 무엇인가요?
StringBuilder의 reverse() 메서드를 사용하는 것입니다.

-----------------------
### 추상 클래스에서 추상 메서드는 필수적인가요?
추상 메서드는 선언만 있고 구현부(body)가 없는 메서드를 의미합니다. 이들은 하위 클래스에서 반드시 구현해야 합니다. 추상 클래스는 이런 추상 메서드를 포함할 수 있지만, 반드시 포함하지 않아도 됩니다.

-----------------------
### 보통의 클래스와 추상 클래스의 차이는 무엇인가요?
일반 클래스는 new 키워드를 사용하여 인스턴스화 할 수 있습니다. 그러나 추상 클래스는 직접 인스턴스화 할 수 없습니다. 추상 클래스는 다른 클래스가 상속받아 사용하는 것을 목적으로 합니다. <br/>
일반 클래스는 추상 메서드를 포함할 수 없습니다. 추상 클래스는 추상 메서드를 포함할 수 있습니다. <br/>
정리하면 일반 클래스는 주로 직접 사용하려는 경우에, 추상 클래스는 코드의 재사용성을 높이고 표준 인터페이스를 제공하려는 경우에 사용됩니다.

-----------------------
### final은 추상 클래스를 수정할 때 사용할 수 있나요?
final은 abstract 클래스나 abstract 메서드에 사용할 수 없습니다. final 클래스는 상속될 수 없기 때문에 abstract를 사용할 수 없습니다. final 메서드는 오버라이드할 수 없기 때문에 abstract 메서드가 될 수 없습니다. 

-----------------------
## 2. Container
-----------------------
### 컨테이너란 무엇인가요?
컨테이너는 특정 객체의 생성과 관리를 담당하여 객체 운용에 필요한 다양한 기능을 제공합니다.

-----------------------
### Collection과 Collections의 차이는 무엇인가요?
Collection은 Java에서 여러 값을 담을 수 있는 객체, 즉 컬렉션을 위한 최상위 인터페이스입니다. List, Set, Queue 등의 컬렉션 인터페이스는 모두 Collection 인터페이스를 상속받습니다.
Collections는 이런 컬렉션을 조작하는 데 도움이 되는 메서드들을 제공하는 클래스입니다. ex) Collections.sort() 

-----------------------
### List, Set, Map의 차이점을 말해주세요.
List는 순서가 있는 컬렉션입니다. List는 중복된 요소를 허용하며 요소의 위치를 기반으로 접근할 수 있습니다. 
Set은 순서를 유지하지 않는 컬렉션입니다. 가장 큰 특징은 중복된 요소를 허용하지 않는다는 것입니다. 
Map은 키와 값의 쌍을 저장하는 데이터 구조입니다. 각 키는 고유하므로 중복을 허용하지 않으며, 각 키는 하나의 값을 가리킵니다.

-----------------------
### HashMap과 Hashtable의 차이는 무엇인가요?
HashMap과 Hashtable은 둘 다 Java에서 사용되는 Map 인터페이스를 구현하는 클래스입니다.
(동기화) HashMap은 동기화되어 있지 않아 기본적으로 스레드 안전하지 않습니다. 
Hashtable은 동기화되어 있어 여러 스레드가 동시에 접근하더라도 스레드 안전성을 보장합니다. 
(Null 허용) HashMap은 null 키와 null 값을 허용합니다. Hashtable은 null 키나 null 값을 허용하지 않습니다. 
(성능) HashMap이 Hashtable보다 일반적으로 빠른 성능을 보입니다. 이는 Hashtable이 동기화를 위한 추가적인 오버헤드를 가지고 있기 때문입니다.

-----------------------
### 각각 어떤 상황에서 HashMap과 TreeMap을 선택하나요?
HashMap은 해시 테이블을 사용하여 요소를 저장합니다. 이로 인해 HashMap의 주요 연산(삽입, 삭제, 탐색)의 시간 복잡도는 일반적으로 O(1)입니다. HashMap은 요소의 삽입 순서를 유지하지 않습니다. 
TreeMap은 균형 이진 검색 트리를 사용하여 요소를 저장합니다. 이로 인해 TreeMap의 주요 연산(삽입, 삭제, 탐색)의 시간 복잡도는 O(log n)입니다. 키는 순서대로 정렬됩니다.

-----------------------
### HashMap 구현 원칙은 무엇인가요?
HashMap은 키 객체의 hashCode() 메서드를 사용하여 해시코드를 생성하고, 이를 이용하여 키-값 쌍을 저장하거나 검색합니다. 
HashMap은 내부적으로 버킷 배열을 사용합니다. 각 버킷은 키-값 쌍을 저장하는 엔트리의 연결 리스트를 참조할 수 있습니다. 
키의 해시코드는 버킷 배열의 인덱스로 변환되어, 해당 키-값 쌍이 저장될 위치를 결정합니다.

-----------------------
### ArrayList와 LinkedList의 차이점은 무엇인가요?
(내부 데이터 구조) ArrayList는 내부적으로 동적 배열을 사용하여 데이터를 저장합니다. 반면에 LinkedList는 이중 연결 리스트를 사용하여 데이터를 저장합니다.
(메모리 사용) ArrayList는 요소의 데이터만 저장하는 반면, LinkedList는 요소의 데이터와 함께 다음 및 이전 노드에 대한 두 개의 참조를 저장해야 하므로 더 많은 메모리를 사용합니다.
(탐색 및 액세스 성능) ArrayList는 인덱스를 기반으로 요소에 직접 접근할 수 있으므로, 요소의 탐색 및 액세스에는 O(1)의 시간 복잡도가 필요합니다. 반면에 LinkedList는 요소의 액세스가 순차적이므로, 리스트의 요소에 접근하는 데 O(n)의 시간 복잡도가 필요합니다.
(삽입 및 삭제 성능) ArrayList는 요소가 삽입되거나 삭제될 때 배열의 크기를 조정해야 하므로, 이 연산에는 O(n)의 시간 복잡도가 필요합니다. 반면에 LinkedList는 양방향 연결 리스트이므로, 리스트의 시작이나 끝에서의 요소의 삽입 및 삭제는 O(1)의 시간 복잡도를 가집니다. 하지만 이는 인덱스가 알려진 경우의 이야기이고, 인덱스가 알려지지 않은 상태에서 LinkedList에서 요소를 찾는 데는 O(n)의 시간이 소요됩니다.

-----------------------
### Array에서 List로 전환하려면 어떻게 해야하나요?
Java에서 배열을 리스트로 전환하는 것은 Arrays 클래스의 asList() 메소드를 사용하여 쉽게 할 수 있습니다.
List<String> list = Arrays.asList(array);
이 변환된 리스트는 고정 크기를 가지므로, ArrayList 생성자를 사용하여 새 ArrayList를 생성하는 것이 좋습니다.
List<String> list = new ArrayList<>(Arrays.asList(array));

-----------------------
### Array와 ArrayList의 차이점을 말해주세요.
Array는 고정된 크기를 가지고, ArrayList는 동적으로 크기가 조정될 수 있는 가변 크기 배열입니다.
Array는 원시 타입과 객체 모두를 저장할 수 있습니다. 
반면에 ArrayList는 객체만을 저장할 수 있으며, 원시 타입은 래퍼 클래스를 통해 객체로 변환되어야 합니다.

-----------------------
### Queue에서, poll()과 remove()의 차이는 무엇인가요?
poll() 메소드는 큐에서 가장 앞에 있는 요소를 제거하고 그 요소를 반환합니다. 만약 큐가 비어있다면 null을 반환합니다.
remove() 메소드도 큐에서 가장 앞에 있는 요소를 제거하고 그 요소를 반환합니다. 그러나 큐가 비어있을 때 remove() 메소드를 호출하면, poll() 메소드와는 달리 NoSuchElementException을 던집니다.

-----------------------
### thread-safe한 컬렉션 클래스들은 무엇이 있을까요?
ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteArraySet, ConcurrentLinkedQueue, ConcurrentLinkedDeque 등이 있습니다.

-----------------------
### iterator란 무엇인가요?
Iterator는 Java의 Collection Framework에서 데이터 요소를 순차적으로 접근하는데 사용되는 인터페이스입니다.

-----------------------
### iterator의 사용 목적은 무엇인가요? 어떤 특징이 있죠?
Iterator를 사용하면 컬렉션의 요소를 순회하는 동안 해당 요소를 안전하게 제거할 수 있습니다. next() 메서드는 순회할 다음 요소를 반환하고, hasNext() 메서드는 순회할 요소가 더 있는지를 확인하고, remove() 메서드는 next() 메서드로 반환된 마지막 요소를 컬렉션에서 제거하는 기능을 제공합니다. 일반적으로 hasNext(), next(), remove() 순으로 메소드를 호출해야 한다.

-----------------------
### iterator와 listIterator의 차이는 무엇인가요?
Iterator는 전진 방향으로만 요소를 순회할 수 있습니다. 반면에 ListIterator는 양방향으로 순회할 수 있습니다. 
ListIterator는 add(E e)와 set(E e)라는 메서드를 제공하여 리스트의 요소를 추가하거나 수정할 수 있습니다. 
반면에 Iterator는 요소를 제거하는 remove() 메서드만 제공하며, 요소를 추가하거나 수정하는 기능은 제공하지 않습니다.

-----------------------
## 3. multi-threading
-----------------------
### 병렬과 동시성의 차이점을 말해주세요.
병렬성은 '실제로 동시에 여러 작업을 처리하는 것'이고(여러 개의 CPU), 동시성은 '한 번에 하나의 작업을 처리하지만, 여러 작업이 동시에 실행되는 것처럼 보이게 하는 것'(한 개의 CPU)입니다.

-----------------------
### 프로세스와 스레드의 차이를 말해주세요.
프로세스는 실행 중인 프로그램의 인스턴스이며, 스레드는 프로세스 내에서 실행되는 가장 작은 실행 단위입니다. 
프로세스는 독립적이며 격리된 반면, 스레드는 자원을 공유하므로 상호작용하기가 더 쉽습니다. 하지만 이런 특성 때문에 동시성 제어가 필요하게 됩니다.

-----------------------
### 데몬 스레드는 무엇인가요?
데몬 스레드는 주 스레드의 작업을 돕는 보조적인 역할을 하는 스레드입니다. 일반적으로 백그라운드에서 실행되어 다른 일반(또는 사용자) 스레드의 동작을 지원합니다.

-----------------------
### 스레드를 만드는 방법을 나열해주세요.
1. Thread 클래스를 확장하는 클래스를 만들고, 그 클래스의 run 메서드를 재정의(오버라이드)합니다. 그런 다음, 그 클래스의 인스턴스를 만들고, start 메서드를 호출하여 스레드를 시작합니다.
2. Runnable 인터페이스를 구현하는 클래스를 만듭니다. 이 인터페이스는 run이라는 단일 메서드만 정의하고 있습니다. Runnable 객체는 Thread 객체에 전달되어 스레드가 시작될 때 실행됩니다.

-----------------------
### runnable과 callable의 차이는 무엇인가요?
Runnable과 Callable은 둘 다 자바에서 별도의 스레드에서 실행되는 작업을 정의하는 인터페이스입니다.
Callable은 Runnable의 확장된 형태로서 결과를 반환할 수 있고 예외를 던질 수 있습니다.

-----------------------
### 스레드의 여러가지 상태에 대해 말해주세요.
New (신규): 스레드가 생성되었지만 아직 시작되지 않은 상태입니다.
Runnable (실행 가능): 스레드가 실행 중이거나 실행을 위해 준비된 상태입니다. 
Blocked (차단됨): 스레드가 기다리는 동안 차단된 상태입니다.
Waiting (대기 중): 스레드가 다른 스레드에 의해 신호를 받을 때까지 무한히 기다리는 상태입니다.
Timed Waiting (시간 제한 대기 중): 스레드가 지정된 시간 동안 기다리는 상태입니다.
Terminated (종료됨): 스레드가 작업을 모두 완료하거나 예외적인 방법으로 종료된 상태입니다.
